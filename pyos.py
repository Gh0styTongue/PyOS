import sysimport datetimeimport configparserimport osimport pickleimport zlibimport tkinter as tkfrom tkinter import ttk, simpledialog, messagebox, font, filedialogimport ioimport zipfileimport tempfileimport subprocessMEDIA_EXTENSIONS = ['.mp3', '.wav', '.ogg', '.mp4', '.mov', '.avi', '.flac']ZIP_EXTENSIONS = ['.zip']class VirtualFileSystem:    def __init__(self, size_bytes, storage_file):        self.max_size = size_bytes        self.storage_file = storage_file        self.root = {'type': 'dir', 'children': {}}        self.load_from_disk()    def get_node_from_path(self, path_str):        parts = [part for part in path_str.split('/') if part]        node = self.root        for part in parts:            if node['type'] == 'dir' and part in node['children']:                node = node['children'][part]            else:                return None        return node    def get_size(self, node=None):        if node is None:            node = self.root        if node['type'] == 'file':            return len(node.get('content', b''))        if node['type'] == 'dir':            return sum(self.get_size(child) for child in node['children'].values())        return 0    def save_to_disk(self):        try:            serialized_data = pickle.dumps(self.root)            compressed_data = zlib.compress(serialized_data, level=9)            with open(self.storage_file, 'wb') as f:                f.write(compressed_data)        except Exception as e:            print(f"Error saving file system: {e}")    def load_from_disk(self):        if not os.path.exists(self.storage_file):            return        try:            with open(self.storage_file, 'rb') as f:                compressed_data = f.read()            if not compressed_data: return            decompressed_data = zlib.decompress(compressed_data)            self.root = pickle.loads(decompressed_data)        except Exception:            print("Warning: Storage file is corrupted or empty. Starting fresh.")            self.root = {'type': 'dir', 'children': {}}class ZipViewer(tk.Toplevel):    def __init__(self, parent, file_bytes):        super().__init__(parent)        self.title("Zip File Contents")        self.geometry("400x300")                self.tree = ttk.Treeview(self, columns=("size",), show="tree headings")        self.tree.heading("#0", text="File Name")        self.tree.heading("size", text="Size")        self.tree.pack(expand=True, fill='both')                self.populate_tree(file_bytes)    def populate_tree(self, file_bytes):        try:            zip_buffer = io.BytesIO(file_bytes)            with zipfile.ZipFile(zip_buffer, 'r') as zf:                for info in zf.infolist():                    self.tree.insert("", "end", text=info.filename, values=(f"{info.file_size} B",))        except zipfile.BadZipFile:            messagebox.showerror("Error", "Invalid or corrupted zip file.", parent=self)            self.destroy()class PyOS_GUI(tk.Tk):    def __init__(self):        super().__init__()        self.fs = None        self.config = configparser.ConfigParser()        self.user = "none"        if not self.boot():            self.destroy()            return                self.title(f"PyOS - Logged in as {self.user}")        self.geometry("800x600")        self.configure(bg="#f0f0f0")                self.current_path = "/"        self.open_file_path = None        self.create_widgets()        self.refresh_file_explorer()                self.protocol("WM_DELETE_WINDOW", self.on_closing)    def on_closing(self):        if self.fs: self.fs.save_to_disk()        self.destroy()    def run_setup(self):        messagebox.showinfo("PyOS Setup", "Welcome to PyOS! Let's set things up.")        user = simpledialog.askstring("Setup", "Enter a username:")        if not user: return False        while True:            size_str = simpledialog.askstring("Setup", "Enter filesystem size (e.g., 10 MB, 1 GB):")            if not size_str: return False            try:                num_part, unit_part = size_str.split()                num = float(num_part)                unit = unit_part.strip().lower()                multiplier = {"kb": 1024, "mb": 1024**2, "gb": 1024**3}.get(unit)                if multiplier is None: raise ValueError                size_bytes = int(num * multiplier)                break            except (ValueError, IndexError, TypeError):                messagebox.showerror("Error", "Invalid format. Use a number and a unit (KB, MB, GB).")        self.config['user'] = {'username': user}        self.config['filesystem'] = {'size_bytes': str(size_bytes), 'storage_file': 'pyos.oss'}        with open('config.ini', 'w') as configfile: self.config.write(configfile)        messagebox.showinfo("Setup Complete", "Setup is complete. Please restart PyOS.")        return True            def boot(self):        if not os.path.exists('config.ini'):            self.withdraw()            return not self.run_setup()        self.config.read('config.ini')        try:            self.user = self.config.get('user', 'username')            size_bytes = self.config.getint('filesystem', 'size_bytes')            storage_file = self.config.get('filesystem', 'storage_file')            self.fs = VirtualFileSystem(size_bytes, storage_file)            return True        except (configparser.NoSectionError, configparser.NoOptionError):            messagebox.showerror("Error", "Config file is corrupted. Deleting it and running setup.")            os.remove('config.ini')            self.withdraw()            return not self.run_setup()    def create_widgets(self):        main_frame = ttk.Frame(self, padding="3 3 12 12")        main_frame.grid(row=0, column=0, sticky="nsew")        self.grid_rowconfigure(0, weight=1); self.grid_columnconfigure(0, weight=1)        paned_window = ttk.PanedWindow(main_frame, orient=tk.HORIZONTAL)        paned_window.grid(row=0, column=0, sticky="nsew")        main_frame.grid_rowconfigure(0, weight=1); main_frame.grid_columnconfigure(0, weight=1)        explorer_frame = ttk.Frame(paned_window, padding=5)        paned_window.add(explorer_frame, weight=1)        explorer_frame.grid_rowconfigure(1, weight=1); explorer_frame.grid_columnconfigure(0, weight=1)        explorer_buttons = ttk.Frame(explorer_frame)        explorer_buttons.grid(row=0, column=0, sticky="ew", pady=5)        ttk.Button(explorer_buttons, text="New File", command=self.new_file).pack(side=tk.LEFT, padx=2)        ttk.Button(explorer_buttons, text="New Folder", command=self.new_folder).pack(side=tk.LEFT, padx=2)        ttk.Button(explorer_buttons, text="Upload", command=self.upload_file).pack(side=tk.LEFT, padx=2)        ttk.Button(explorer_buttons, text="Download", command=self.download_file).pack(side=tk.LEFT, padx=2)        ttk.Button(explorer_buttons, text="Delete", command=self.delete_item).pack(side=tk.LEFT, padx=2)        self.file_tree = ttk.Treeview(explorer_frame, columns=("size",), show="tree headings")        self.file_tree.heading("#0", text="Name"); self.file_tree.heading("size", text="Size")        self.file_tree.column("size", width=80, anchor='e')        self.file_tree.grid(row=1, column=0, sticky="nsew")        self.file_tree.bind("<Double-1>", self.on_item_double_click)        editor_frame = ttk.Frame(paned_window, padding=5)        paned_window.add(editor_frame, weight=3)        editor_frame.grid_rowconfigure(0, weight=1); editor_frame.grid_columnconfigure(0, weight=1)        self.editor_text = tk.Text(editor_frame, wrap="word", undo=True, font=("Helvetica", 12))        self.editor_text.grid(row=0, column=0, sticky="nsew")        editor_buttons = ttk.Frame(editor_frame)        editor_buttons.grid(row=1, column=0, sticky="ew", pady=5)        ttk.Button(editor_buttons, text="Save File", command=self.save_file).pack(side=tk.LEFT)        self.status_bar = ttk.Label(main_frame, text="Ready", relief=tk.SUNKEN, anchor=tk.W)        self.status_bar.grid(row=1, column=0, sticky="ew")        self.update_status_bar()    def refresh_file_explorer(self):        for i in self.file_tree.get_children(): self.file_tree.delete(i)        if self.current_path != "/": self.file_tree.insert("", "end", text=".. (Up)", values=("DIR",), open=True)        current_node = self.fs.get_node_from_path(self.current_path)        if not current_node: return        children = sorted(current_node['children'].items(), key=lambda x: (x[1]['type'] != 'dir', x[0]))        for name, node in children:            full_path = os.path.join(self.current_path, name).replace('\\', '/')            if node['type'] == 'dir':                self.file_tree.insert("", "end", iid=full_path, text=f"📁 {name}", values=("DIR",))            else:                self.file_tree.insert("", "end", iid=full_path, text=f"� {name}", values=(self.format_size(self.fs.get_size(node)),))        self.update_status_bar()    def format_size(self, b):        if b >= 1024**3: return f"{b/1024**3:.2f}G"        if b >= 1024**2: return f"{b/1024**2:.2f}M"        if b >= 1024: return f"{b/1024:.2f}K"        return f"{b}B"            def update_status_bar(self):        used = self.fs.get_size()        self.status_bar.config(text=f"Path: {self.current_path} | Used: {self.format_size(used)} of {self.format_size(self.fs.max_size)}")    def on_item_double_click(self, event):        item_id = self.file_tree.focus()        item_text = self.file_tree.item(item_id, "text")        if not item_id: return        if item_text == ".. (Up)":            self.current_path = os.path.dirname(self.current_path).replace('\\', '/') or "/"            self.refresh_file_explorer(); return                    node = self.fs.get_node_from_path(item_id)        if not node: return        if node['type'] == 'dir':            self.current_path = item_id            self.refresh_file_explorer()        elif node['type'] == 'file':            filename = os.path.basename(item_id)            if any(filename.lower().endswith(ext) for ext in ZIP_EXTENSIONS):                ZipViewer(self, node.get('content', b''))            elif any(filename.lower().endswith(ext) for ext in MEDIA_EXTENSIONS):                self.play_media_file(filename, node.get('content', b''))            else:                self.open_in_editor(item_id, node)    def open_in_editor(self, path, node):        self.open_file_path = path        content_bytes = node.get('content', b'')        try:            content_str = content_bytes.decode('utf-8')            self.editor_text.delete(1.0, tk.END)            self.editor_text.insert(tk.END, content_str)            self.editor_text.config(state=tk.NORMAL)            self.title(f"PyOS - Editing {os.path.basename(path)}")        except UnicodeDecodeError:            self.editor_text.delete(1.0, tk.END)            self.editor_text.insert(tk.END, "[Cannot edit binary file]")            self.editor_text.config(state=tk.DISABLED)            self.title(f"PyOS - Viewing {os.path.basename(path)}")                def play_media_file(self, filename, content_bytes):        try:            suffix = os.path.splitext(filename)[1]            with tempfile.NamedTemporaryFile(delete=False, suffix=suffix) as tmp:                tmp.write(content_bytes)                tmp_path = tmp.name                        if sys.platform == "win32":                os.startfile(tmp_path)            elif sys.platform == "darwin":                subprocess.run(["open", tmp_path])            else:                subprocess.run(["xdg-open", tmp_path])        except Exception as e:            messagebox.showerror("Media Player Error", f"Could not play file: {e}")    def new_file(self):        filename = simpledialog.askstring("New File", "Enter filename:")        if not filename: return        self.write_file_content(os.path.join(self.current_path, filename).replace('\\', '/'), b"")    def new_folder(self):        dirname = simpledialog.askstring("New Folder", "Enter folder name:")        if not dirname: return        parent_node = self.fs.get_node_from_path(self.current_path)        if dirname in parent_node['children']:            messagebox.showerror("Error", "A file or folder with that name already exists.")            return        parent_node['children'][dirname] = {'type': 'dir', 'children': {}}        self.fs.save_to_disk(); self.refresh_file_explorer()    def delete_item(self):        selected_id = self.file_tree.focus()        if not selected_id or self.file_tree.item(selected_id, "text") == ".. (Up)":            messagebox.showwarning("Delete", "Please select a file or folder to delete.")            return        item_name = os.path.basename(selected_id)        if not messagebox.askyesno("Confirm Delete", f"Are you sure you want to permanently delete '{item_name}'?"):            return        parent_path = os.path.dirname(selected_id).replace('\\', '/') or "/"        parent_node = self.fs.get_node_from_path(parent_path)        if parent_node and item_name in parent_node['children']:            del parent_node['children'][item_name]            self.fs.save_to_disk(); self.refresh_file_explorer()        def upload_file(self):        local_path = filedialog.askopenfilename()        if not local_path: return        filename = os.path.basename(local_path)        virtual_path = os.path.join(self.current_path, filename).replace('\\', '/')        try:            with open(local_path, 'rb') as f:                content = f.read()        except Exception as e:            messagebox.showerror("Upload Error", f"Could not read file: {e}"); return        self.write_file_content(virtual_path, content)    def download_file(self):        selected_id = self.file_tree.focus()        if not selected_id or self.file_tree.item(selected_id, "values")[0] == "DIR":            messagebox.showwarning("Download", "Please select a file to download."); return        node = self.fs.get_node_from_path(selected_id)        if not node or node['type'] != 'file': return        filename = os.path.basename(selected_id)        local_path = filedialog.asksaveasfilename(initialfile=filename)        if not local_path: return        try:            with open(local_path, 'wb') as f:                f.write(node.get('content', b''))            messagebox.showinfo("Success", f"File '{filename}' downloaded successfully.")        except Exception as e:            messagebox.showerror("Download Error", f"Could not save file: {e}")    def save_file(self):        if not self.open_file_path or self.editor_text.cget('state') == tk.DISABLED:            messagebox.showwarning("Save", "No editable file is open to save."); return        content_bytes = self.editor_text.get(1.0, tk.END).strip().encode('utf-8')        if self.write_file_content(self.open_file_path, content_bytes):            messagebox.showinfo("Save", f"File '{os.path.basename(self.open_file_path)}' saved.")    def write_file_content(self, path, content_bytes):        parent_path = os.path.dirname(path).replace('\\', '/') or "/"        filename = os.path.basename(path)        parent_node = self.fs.get_node_from_path(parent_path)        if not parent_node: return False                if filename in parent_node['children'] and not messagebox.askyesno("Overwrite", f"'{filename}' already exists. Overwrite?"):            return False        current_size = self.fs.get_size()        existing_size = self.fs.get_size(parent_node['children'][filename]) if filename in parent_node['children'] else 0        new_size = len(content_bytes)        if current_size - existing_size + new_size > self.fs.max_size:            messagebox.showerror("Error", "Not enough space on the device."); return False        parent_node['children'][filename] = {'type': 'file', 'content': content_bytes}        self.fs.save_to_disk(); self.refresh_file_explorer()        return Trueif __name__ == "__main__":    app = PyOS_GUI()    if app.fs: app.mainloop()